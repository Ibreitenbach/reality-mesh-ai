<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Mesh Capture</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #fff;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        button {
            padding: 15px 30px;
            font-size: 16px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            background: #007AFF;
            color: white;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0, 122, 255, 0.4);
            transition: all 0.3s;
        }

        button:active {
            background: #0051D5;
            transform: scale(0.95);
        }

        button:disabled {
            background: #333;
            cursor: not-allowed;
            box-shadow: none;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }

        #status {
            color: #4CAF50;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .error {
            color: #ff4444 !important;
        }

        .loading {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-left: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>

        <div id="info">
            <div id="status">Loading...</div>
            <div id="details">Initializing app</div>
        </div>

        <div id="controls">
            <button id="startBtn" disabled>Start Capture</button>
            <button id="captureBtn" disabled>Capture Mesh</button>
            <button id="exportBtn" disabled>Export Mesh</button>
        </div>
    </div>

    <script type="module">
        // Inline Three.js imports from CDN
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
        import { OBJExporter } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/exporters/OBJExporter.js';

        class MeshCaptureApp {
            constructor() {
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');

                this.statusEl = document.getElementById('status');
                this.detailsEl = document.getElementById('details');

                this.startBtn = document.getElementById('startBtn');
                this.captureBtn = document.getElementById('captureBtn');
                this.exportBtn = document.getElementById('exportBtn');

                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.capturedMesh = null;
                this.pointCloud = [];

                this.isCapturing = false;
                this.frameCount = 0;

                this.init();
            }

            async init() {
                this.updateStatus('Requesting camera...', 'Please allow camera access');

                try {
                    // Check if getUserMedia is supported
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Camera API not supported on this device/browser');
                    }

                    // Request camera - try environment camera first
                    let constraints = {
                        video: {
                            facingMode: { ideal: 'environment' },
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    };

                    console.log('Requesting camera...');
                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    console.log('Camera stream obtained:', stream.getVideoTracks()[0].getSettings());

                    this.video.srcObject = stream;

                    // Wait for video to load
                    await new Promise((resolve, reject) => {
                        this.video.onloadedmetadata = () => {
                            console.log('Video metadata loaded');
                            this.video.play()
                                .then(() => {
                                    console.log('Video playing');
                                    resolve();
                                })
                                .catch(reject);
                        };

                        // Timeout after 10 seconds
                        setTimeout(() => reject(new Error('Video load timeout')), 10000);
                    });

                    // Set canvas size
                    this.canvas.width = this.video.videoWidth || 1280;
                    this.canvas.height = this.video.videoHeight || 720;

                    console.log('Canvas size:', this.canvas.width, 'x', this.canvas.height);

                    this.setupThreeJS();
                    this.setupEventListeners();

                    this.updateStatus('Ready!', 'Camera active - tap Start Capture');
                    this.startBtn.disabled = false;

                } catch (error) {
                    this.updateStatus('Error', error.message, true);
                    console.error('Init error:', error);
                }
            }

            setupThreeJS() {
                this.scene = new THREE.Scene();
                this.scene.background = null;

                this.camera = new THREE.PerspectiveCamera(
                    75,
                    this.canvas.width / this.canvas.height,
                    0.1,
                    1000
                );
                this.camera.position.z = 5;

                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: true
                });
                this.renderer.setSize(this.canvas.width, this.canvas.height);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(1, 1, 1);
                this.scene.add(directionalLight);

                console.log('Three.js setup complete');
            }

            setupEventListeners() {
                this.startBtn.addEventListener('click', () => this.startCapture());
                this.captureBtn.addEventListener('click', () => this.captureMesh());
                this.exportBtn.addEventListener('click', () => this.exportMesh());
            }

            startCapture() {
                this.isCapturing = true;
                this.frameCount = 0;
                this.pointCloud = [];

                this.startBtn.disabled = true;
                this.captureBtn.disabled = false;

                this.updateStatus('Capturing...', 'Move camera around object');

                this.captureLoop();
            }

            captureLoop() {
                if (!this.isCapturing) return;

                // Draw video frame to canvas
                this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);

                // Get image data for processing
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);

                // Process frame
                this.estimateDepthAndAddPoints(imageData);

                this.frameCount++;
                this.detailsEl.textContent = `Frames: ${this.frameCount} | Points: ${this.pointCloud.length}`;

                requestAnimationFrame(() => this.captureLoop());
            }

            estimateDepthAndAddPoints(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const step = 8; // Sample every 8 pixels for performance

                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        // Brightness-based depth estimation
                        const brightness = (r + g + b) / 3;
                        const depth = (255 - brightness) / 255 * 2;

                        // Convert to 3D coordinates
                        const nx = (x / width - 0.5) * 2;
                        const ny = -(y / height - 0.5) * 2;

                        this.pointCloud.push({
                            x: nx * 3,
                            y: ny * 3,
                            z: -depth * 2,
                            r: r / 255,
                            g: g / 255,
                            b: b / 255
                        });
                    }
                }
            }

            captureMesh() {
                this.isCapturing = false;
                this.captureBtn.disabled = true;

                this.updateStatus('Processing...', 'Generating mesh');

                setTimeout(() => {
                    this.createMeshFromPointCloud();
                    this.updateStatus('Mesh Created!', `${this.pointCloud.length} points`);
                    this.exportBtn.disabled = false;
                    this.startBtn.disabled = false;
                }, 500);
            }

            createMeshFromPointCloud() {
                if (this.capturedMesh) {
                    this.scene.remove(this.capturedMesh);
                }

                const geometry = new THREE.BufferGeometry();
                const positions = [];
                const colors = [];

                for (const point of this.pointCloud) {
                    positions.push(point.x, point.y, point.z);
                    colors.push(point.r, point.g, point.b);
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

                const material = new THREE.PointsMaterial({
                    size: 0.05,
                    vertexColors: true,
                    sizeAttenuation: true
                });

                this.capturedMesh = new THREE.Points(geometry, material);
                this.scene.add(this.capturedMesh);

                this.animateMesh();
            }

            animateMesh() {
                if (!this.capturedMesh) return;

                this.capturedMesh.rotation.y += 0.01;
                this.renderer.render(this.scene, this.camera);

                requestAnimationFrame(() => this.animateMesh());
            }

            exportMesh() {
                if (!this.capturedMesh) {
                    alert('No mesh to export!');
                    return;
                }

                this.updateStatus('Exporting...', 'Creating files');

                try {
                    const exporter = new OBJExporter();
                    const objData = exporter.parse(this.capturedMesh);

                    const metadata = {
                        captureDate: new Date().toISOString(),
                        pointCount: this.pointCloud.length,
                        frameCount: this.frameCount,
                        device: navigator.userAgent,
                        format: 'obj'
                    };

                    this.downloadFile(objData, 'mesh_capture.obj', 'text/plain');
                    this.downloadFile(
                        JSON.stringify(metadata, null, 2),
                        'mesh_metadata.json',
                        'application/json'
                    );

                    this.updateStatus('Exported!', 'Files saved to Downloads');

                } catch (error) {
                    this.updateStatus('Export failed', error.message, true);
                    console.error('Export error:', error);
                }
            }

            downloadFile(content, filename, mimeType) {
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            updateStatus(status, details, isError = false) {
                this.statusEl.textContent = status;
                this.detailsEl.textContent = details;

                if (isError) {
                    this.statusEl.classList.add('error');
                } else {
                    this.statusEl.classList.remove('error');
                }
            }
        }

        // Start app when page loads
        window.addEventListener('load', () => {
            console.log('App starting...');
            new MeshCaptureApp();
        });
    </script>
</body>
</html>