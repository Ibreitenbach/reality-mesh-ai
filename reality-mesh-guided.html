<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reality Mesh - Guided Capture</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace; background: #0a0a0a; color: #fff; overflow: hidden; }
        #app { width: 100vw; height: 100vh; position: relative; }
        #mode-screen { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 100%); }
        .mode-screen.hidden { display: none; }
        h1 { font-size: 2.5rem; background: linear-gradient(to right, #22d3ee, #3b82f6); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 1rem; text-align: center; }
        .subtitle { color: #9ca3af; margin-bottom: 2rem; text-align: center; max-width: 500px; }
        .mode-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; max-width: 600px; width: 100%; margin-bottom: 20px; }
        @media (max-width: 600px) { .mode-grid { grid-template-columns: 1fr; } }
        .mode-card { background: rgba(31, 41, 55, 0.8); border: 2px solid #374151; border-radius: 15px; padding: 20px; cursor: pointer; transition: all 0.3s; text-align: center; }
        .mode-card:hover { border-color: #22d3ee; transform: translateY(-5px); box-shadow: 0 10px 30px rgba(34, 211, 238, 0.3); }
        .mode-icon { font-size: 3rem; margin-bottom: 10px; }
        .mode-title { font-size: 1.3rem; font-weight: 600; color: #22d3ee; margin-bottom: 8px; }
        .mode-desc { font-size: 0.9rem; color: #9ca3af; line-height: 1.4; }
        .mode-time { font-size: 0.8rem; color: #6b7280; margin-top: 8px; font-weight: 600; }
        #capture-screen { position: absolute; inset: 0; background: #000; }
        .capture-screen.hidden { display: none; }
        #video { width: 100%; height: 100%; object-fit: cover; }
        #canvas-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        .guidance-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; pointer-events: none; z-index: 10; }
        .guidance-circle { width: 200px; height: 200px; border: 4px dashed #22d3ee; border-radius: 50%; animation: rotate 3s linear infinite; margin: 0 auto 20px; position: relative; }
        .guidance-arrow { position: absolute; font-size: 3rem; color: #22d3ee; animation: pulse 1.5s ease-in-out infinite; }
        .arrow-left { left: -60px; top: 50%; transform: translateY(-50%); }
        .arrow-right { right: -60px; top: 50%; transform: translateY(-50%); }
        .arrow-up { top: -60px; left: 50%; transform: translateX(-50%); }
        .arrow-down { bottom: -60px; left: 50%; transform: translateX(-50%); }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.2); } }
        .guidance-text { background: rgba(0, 0, 0, 0.8); padding: 15px 25px; border-radius: 15px; font-size: 1.2rem; font-weight: 600; color: #22d3ee; border: 2px solid #22d3ee; }
        .progress-bar { position: absolute; top: 20px; left: 20px; right: 20px; height: 8px; background: rgba(0, 0, 0, 0.8); border-radius: 10px; overflow: hidden; border: 1px solid #22d3ee; }
        .progress-fill { height: 100%; background: linear-gradient(to right, #22d3ee, #3b82f6); width: 0%; transition: width 0.3s; }
        .stats-panel { position: absolute; bottom: 120px; left: 20px; background: rgba(0, 0, 0, 0.8); padding: 15px 20px; border-radius: 10px; border: 1px solid #374151; font-size: 0.9rem; }
        .stat-row { display: flex; justify-content: space-between; gap: 20px; margin: 5px 0; }
        .stat-label { color: #9ca3af; }
        .stat-value { color: #22d3ee; font-weight: 600; }
        .controls { position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 15px; }
        button { padding: 15px 30px; font-size: 16px; font-weight: 600; border: none; border-radius: 50px; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background: #22d3ee; color: #0a0a0a; box-shadow: 0 0 20px rgba(34, 211, 238, 0.4); }
        .btn-danger { background: #ef4444; color: #fff; }
        .btn-success { background: #10b981; color: #fff; }
        button:active { transform: scale(0.95); }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="app">
        <div id="mode-screen" class="mode-screen">
            <h1>üéØ Reality Mesh AI</h1>
            <p class="subtitle">Choose your capture technique for optimal 3D reconstruction</p>
            <div class="mode-grid">
                <div class="mode-card" onclick="app.selectMode('orbital')"><div class="mode-icon">üîÑ</div><div class="mode-title">Quick Orbital</div><div class="mode-desc">Circle around object at eye level</div><div class="mode-time">‚è±Ô∏è 30-60 seconds</div></div>
                <div class="mode-card" onclick="app.selectMode('multi-height')"><div class="mode-icon">üìê</div><div class="mode-title">Multi-Height Pro</div><div class="mode-desc">Multiple circles at different heights</div><div class="mode-time">‚è±Ô∏è 2-3 minutes</div></div>
                <div class="mode-card" onclick="app.selectMode('zoom')"><div class="mode-icon">üéØ</div><div class="mode-title">Zoom In/Out</div><div class="mode-desc">Move closer and farther from object</div><div class="mode-time">‚è±Ô∏è 15-30 seconds</div></div>
                <div class="mode-card" onclick="app.selectMode('room')"><div class="mode-icon">üè†</div><div class="mode-title">Room Scanner</div><div class="mode-desc">Grid sweep of entire space</div><div class="mode-time">‚è±Ô∏è 3-5 minutes</div></div>
            </div>
            <div class="mode-card" onclick="app.selectMode('free')" style="max-width: 600px; width: 100%;"><div class="mode-icon">‚ú®</div><div class="mode-title">Free Capture</div><div class="mode-desc">No guidance - capture however you like</div><div class="mode-time">‚è±Ô∏è Your pace</div></div>
        </div>
        <div id="capture-screen" class="capture-screen hidden">
            <video id="video" autoplay playsinline muted></video>
            <canvas id="canvas-overlay"></canvas>
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
            <div id="guidance" class="guidance-overlay">
                <div class="guidance-circle">
                    <div id="arrow-left" class="guidance-arrow arrow-left hidden">‚¨ÖÔ∏è</div>
                    <div id="arrow-right" class="guidance-arrow arrow-right hidden">‚û°Ô∏è</div>
                    <div id="arrow-up" class="guidance-arrow arrow-up hidden">‚¨ÜÔ∏è</div>
                    <div id="arrow-down" class="guidance-arrow arrow-down hidden">‚¨áÔ∏è</div>
                </div>
                <div class="guidance-text" id="guidance-text">Loading...</div>
            </div>
            <div class="stats-panel">
                <div class="stat-row"><span class="stat-label">Frames:</span><span class="stat-value" id="stat-frames">0</span></div>
                <div class="stat-row"><span class="stat-label">Points:</span><span class="stat-value" id="stat-points">0</span></div>
                <div class="stat-row"><span class="stat-label">Rotation:</span><span class="stat-value" id="stat-rotation">0¬∞</span></div>
                <div class="stat-row"><span class="stat-label">Speed:</span><span class="stat-value" id="stat-speed">0 ft/s</span></div>
            </div>
            <div class="controls"><button class="btn-danger" onclick="app.stop()">Stop & Export</button></div>
        </div>
    </div>
    <script>
        class RealityMeshApp {
            constructor() {
                this.mode = null;
                this.video = document.getElementById('video');
                this.canvas = document.getElementById('canvas-overlay');
                this.ctx = null;
                this.isCapturing = false;
                this.startTime = 0;
                this.frameCount = 0;
                this.pointCloud = [];
                this.sensorData = [];
                this.initialHeading = null;
                this.currentHeading = 0;
                this.totalRotation = 0;
                this.lastHeading = 0;
                this.guidanceSteps = {
                    'orbital': [
                        { text: 'Position object in center', duration: 3000 },
                        { text: 'Walk slowly in a circle ‚Üí', duration: 30000, arrow: 'right' },
                        { text: 'Keep moving at steady pace', duration: 30000 }
                    ],
                    'multi-height': [
                        { text: 'Starting: Eye level orbital', duration: 45000 },
                        { text: 'Move up: High angle orbital ‚¨ÜÔ∏è', duration: 45000, arrow: 'up' },
                        { text: 'Move down: Low angle orbital ‚¨áÔ∏è', duration: 45000, arrow: 'down' }
                    ],
                    'zoom': [
                        { text: 'Start 10 feet away', duration: 2000 },
                        { text: 'Walk slowly toward object', duration: 15000 },
                        { text: 'Stop 1-2 feet away', duration: 2000 }
                    ],
                    'room': [
                        { text: 'Start at corner of room', duration: 3000 },
                        { text: 'Pan slowly left to right', duration: 30000 },
                        { text: 'Step forward, pan back', duration: 30000 },
                        { text: 'Continue grid pattern', duration: 60000 }
                    ],
                    'free': [
                        { text: 'Capture freely - ensure good coverage', duration: 999999 }
                    ]
                };
                this.currentStep = 0;
                this.stepStartTime = 0;
            }
            selectMode(mode) {
                this.mode = mode;
                this.startCapture();
            }
            async startCapture() {
                document.getElementById('mode-screen').classList.add('hidden');
                document.getElementById('capture-screen').classList.remove('hidden');
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: { facingMode: 'environment', width: 1280, height: 720 },
                        audio: false
                    });
                    this.video.srcObject = stream;
                    this.video.onloadedmetadata = () => {
                        this.canvas.width = this.video.videoWidth || 1280;
                        this.canvas.height = this.video.videoHeight || 720;
                        this.ctx = this.canvas.getContext('2d');
                        this.isCapturing = true;
                        this.startTime = Date.now();
                        this.stepStartTime = Date.now();
                        this.startSensors();
                        this.updateGuidance();
                        this.captureLoop();
                    };
                } catch (error) {
                    console.error('Camera error:', error);
                    alert('Camera access denied: ' + error.message);
                    this.reset();
                }
            }
            startSensors() {
                window.addEventListener('deviceorientation', (e) => {
                    if (this.initialHeading === null && e.alpha !== null) {
                        this.initialHeading = e.alpha;
                    }
                    if (e.alpha !== null) {
                        this.currentHeading = e.alpha;
                        let delta = this.currentHeading - this.lastHeading;
                        if (delta > 180) delta -= 360;
                        if (delta < -180) delta += 360;
                        this.totalRotation += Math.abs(delta);
                        this.lastHeading = this.currentHeading;
                        document.getElementById('stat-rotation').textContent = Math.round(this.totalRotation) + '¬∞';
                    }
                    this.sensorData.push({
                        frame: this.frameCount,
                        timestamp: Date.now(),
                        orientation: { alpha: e.alpha, beta: e.beta, gamma: e.gamma }
                    });
                });
            }
            updateGuidance() {
                if (!this.isCapturing) return;
                const steps = this.guidanceSteps[this.mode];
                const elapsed = Date.now() - this.stepStartTime;
                if (this.currentStep < steps.length && elapsed >= steps[this.currentStep].duration) {
                    this.currentStep++;
                    this.stepStartTime = Date.now();
                }
                if (this.currentStep < steps.length) {
                    const step = steps[this.currentStep];
                    document.getElementById('guidance-text').textContent = step.text;
                    ['left', 'right', 'up', 'down'].forEach(dir => {
                        document.getElementById(`arrow-${dir}`).classList.add('hidden');
                    });
                    if (step.arrow) {
                        document.getElementById(`arrow-${step.arrow}`).classList.remove('hidden');
                    }
                    const totalDuration = steps.reduce((sum, s) => sum + s.duration, 0);
                    const currentProgress = steps.slice(0, this.currentStep).reduce((sum, s) => sum + s.duration, 0) + elapsed;
                    const progress = Math.min(100, (currentProgress / totalDuration) * 100);
                    document.getElementById('progress-fill').style.width = progress + '%';
                }
                setTimeout(() => this.updateGuidance(), 100);
            }
            captureLoop() {
                if (!this.isCapturing) return;
                if (this.frameCount % 3 === 0) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = this.video.videoWidth;
                    tempCanvas.height = this.video.videoHeight;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(this.video, 0, 0);
                    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    this.processFrame(imageData);
                }
                this.frameCount++;
                document.getElementById('stat-frames').textContent = Math.floor(this.frameCount / 3);
                document.getElementById('stat-points').textContent = this.pointCloud.length;
                requestAnimationFrame(() => this.captureLoop());
            }
            processFrame(imageData) {
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                const step = 20;
                for (let y = 0; y < height; y += step) {
                    for (let x = 0; x < width; x += step) {
                        const i = (y * width + x) * 4;
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const brightness = (r + g + b) / 3;
                        const depth = (255 - brightness) / 255;
                        const nx = (x / width - 0.5) * 2;
                        const ny = -(y / height - 0.5) * 2;
                        this.pointCloud.push({
                            x: nx * 3,
                            y: ny * 3,
                            z: -depth * 2,
                            r: r / 255,
                            g: g / 255,
                            b: b / 255,
                            frame: this.frameCount
                        });
                    }
                }
            }
            stop() {
                this.isCapturing = false;
                if (this.video.srcObject) {
                    this.video.srcObject.getTracks().forEach(track => track.stop());
                }
                const duration = (Date.now() - this.startTime) / 1000;
                const data = {
                    metadata: {
                        timestamp: new Date().toISOString(),
                        mode: this.mode,
                        duration: duration,
                        frameCount: this.frameCount,
                        pointCount: this.pointCloud.length,
                        totalRotation: this.totalRotation,
                        device: navigator.userAgent
                    },
                    sensors: this.sensorData,
                    pointCloud: this.pointCloud.slice(0, 10000)
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `reality-mesh-${this.mode}-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                alert(`Capture Complete!\n\nMode: ${this.mode}\nDuration: ${duration.toFixed(1)}s\nFrames: ${this.frameCount}\nPoints: ${this.pointCloud.length}\nRotation: ${Math.round(this.totalRotation)}¬∞\n\nData exported!`);
                this.reset();
            }
            reset() {
                location.reload();
            }
        }
        window.app = new RealityMeshApp();
    </script>
</body>
</html>